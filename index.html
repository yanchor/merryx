<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä¸ºä½ åœ¨æ˜Ÿç©ºä¸­ç§ä¸€æ£µæ ‘</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Helvetica Neue', sans-serif;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        #video-input { 
            position: absolute; 
            top: 0; 
            left: 0; 
            opacity: 0; 
            pointer-events: none; 
            z-index: 0;
        }
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .loader-text {
            font-size: 24px;
            letter-spacing: 4px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        .instruction {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            margin-top: 10px;
        }
        #status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            z-index: 5;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        /* å…¨å±æŒ‰é’®æ ·å¼ */
        #fullscreen-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            background: rgba(255, 255, 255, 0.1);
            color: #ffd700;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            font-family: 'Helvetica Neue', sans-serif;
            letter-spacing: 1px;
            pointer-events: auto; /* ç¡®ä¿å¯ç‚¹å‡» */
        }
        #fullscreen-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            transform: scale(1.05);
            color: #fff;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="loader-text">âœ¦ æ­£åœ¨ç¼–ç»‡æ˜Ÿç©º âœ¦</div>
    <div class="instruction">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯é­”æ³•<br>æ¡æ‹³å‡èš Â· å¼ æ‰‹é‡Šæ”¾</div>
</div>

<div id="status-indicator">ç­‰å¾…æ‘„åƒå¤´...</div>
<!-- å…¨å±æŒ‰é’® -->
<button id="fullscreen-btn">â›¶ å…¨å±è§‚çœ‹</button>

<div id="canvas-container"></div>
<video id="video-input" playsinline></video>

<!-- æ ¸å¿ƒåº“ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- åå¤„ç†åº“ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<!-- MediaPipe (é”å®šç‰ˆæœ¬ä»¥é˜²æŠ¥é”™) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1629030981/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

<!-- 1. æ™®é€šç²’å­ç€è‰²å™¨ (æ ‘+æ–‡å­—) -->
<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute vec3 customColor;
    varying vec3 vColor;
    void main() {
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    uniform vec3 color;
    varying vec3 vColor;
    void main() {
        vec2 xy = gl_PointCoord.xy - vec2(0.5);
        float ll = length(xy);
        if(ll > 0.5) discard;
        float alpha = (0.5 - ll) * 2.0;
        gl_FragColor = vec4(color * vColor, alpha);
    }
</script>

<!-- 2. é›ªèŠ±ç²’å­ç€è‰²å™¨ (å…­èŠ’æ˜Ÿ) -->
<script type="x-shader/x-fragment" id="snowFragmentShader">
    uniform vec3 color;
    varying vec3 vColor;
    void main() {
        vec2 uv = gl_PointCoord.xy - 0.5;
        float r = length(uv);
        float a = atan(uv.y, uv.x);
        float shape = 0.5 * (0.6 + 0.4 * cos(a * 6.0)); 
        float alpha = smoothstep(shape, shape - 0.1, r * 2.0); 
        if (alpha < 0.1) discard;
        gl_FragColor = vec4(color * vColor * 1.5, alpha);
    }
</script>

<script>
    /**
     * é…ç½®ä¸çŠ¶æ€
     */
    const CONFIG = {
        particleCount: 35000, 
        treeHeight: 650,
        treeBaseRadius: 260,
        trunkHeight: 120, 
        trunkRadius: 40,  
        levels: 12, 
        lightLoops: 8, 
        textString: "MERRY CHRISTMAS", 
        subtitleString: "To é‚“è¯—è¯­", 
        colors: {
            leaf: [new THREE.Color(0x0f3d0f), new THREE.Color(0x2d5a27), new THREE.Color(0x5cb85c), new THREE.Color(0x91e884)], 
            star: new THREE.Color(0xffeb3b), 
            trunk: new THREE.Color(0x5C4033), 
            ornaments: [new THREE.Color(0xff3333), new THREE.Color(0xffd700), new THREE.Color(0xe0e0e0), new THREE.Color(0x00bfff)],
            lights: [new THREE.Color(0xffaa00), new THREE.Color(0xffecb3)],
            text: new THREE.Color(0xffd700) 
        }
    };

    let state = {
        visualState: 'TREE', 
        explosionStartTime: 0
    };

    let scene, camera, renderer, composer;
    let particles, geometry, material;
    let backgroundSnow, snowMaterial; 
    let treeRotation = 0; 
    
    let originalPositions = []; 
    let randomness = [];
    let particleTypes = []; // 0:Tree, 1:Text
    
    function init() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.0015);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
        camera.position.z = 900;
        camera.position.y = 0; 

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        createParticles();
        createBackgroundSnow(); 

        window.addEventListener('resize', onWindowResize, false);
        
        // å…¨å±æŒ‰é’®é€»è¾‘
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        fullscreenBtn.addEventListener('click', toggleFullScreen);
        
        document.addEventListener('fullscreenchange', () => {
             if (!document.fullscreenElement) {
                fullscreenBtn.innerHTML = 'â›¶ å…¨å±è§‚çœ‹';
             } else {
                fullscreenBtn.innerHTML = 'âœ• é€€å‡ºå…¨å±';
             }
        });

        animate();
    }
    
    function toggleFullScreen() {
        const btn = document.getElementById('fullscreen-btn');
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable full-screen mode: ${err.message}`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    /**
     * è¾…åŠ©ï¼šç”Ÿæˆå¹³é¢æ–‡å­— (ç”¨äºä¸»æ ‡é¢˜å’Œå‰¯æ ‡é¢˜)
     */
    function generateFlatText(text, xOffset, yOffset, zOffset, scale) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 256;
        
        ctx.font = 'bold 100px "Times New Roman", "Songti SC", "SimSun", serif';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const positions = [];
        const step = 4; 

        for(let y = 0; y < canvas.height; y += step) {
            for(let x = 0; x < canvas.width; x += step) {
                const index = (y * canvas.width + x) * 4;
                if(data[index+3] > 128) {
                    // å¹³é¢æ˜ å°„
                    let px = (x - canvas.width/2) * scale + xOffset;
                    let py = -(y - canvas.height/2) * scale + yOffset;
                    let pz = zOffset;
                    positions.push(px, py, pz);
                }
            }
        }
        return positions;
    }

    function createParticles() {
        geometry = new THREE.BufferGeometry();
        
        // 1. ç”Ÿæˆä¸»æ ‡é¢˜ - å¹³é¢ï¼Œä¸‹ç§»è‡³ 450 (åŸ550)ï¼Œå±…ä¸­
        const titlePositions = generateFlatText(CONFIG.textString, 0, 450, 0, 0.5);
        // 2. ç”Ÿæˆå‰¯æ ‡é¢˜ - ä¿æŒåœ¨å³ä¾§ (ä»320è°ƒæ•´åˆ°200ï¼Œå‘å·¦ç§»åŠ¨)
        const subtitlePositions = generateFlatText(CONFIG.subtitleString, 200, 100, 0, 0.4);
        
        // åˆå¹¶æ–‡å­—æ•°æ®
        const allTextPositions = [...titlePositions, ...subtitlePositions];
        const textParticleCount = allTextPositions.length / 3;

        const totalParticles = CONFIG.particleCount + textParticleCount;
        
        const posArray = [];
        const colArray = [];
        const sizeArray = [];

        originalPositions = new Float32Array(totalParticles * 3);
        randomness = new Float32Array(totalParticles * 3);
        particleTypes = new Uint8Array(totalParticles); 

        // --- ç”Ÿæˆæ ‘ç²’å­ ---
        for (let i = 0; i < CONFIG.particleCount; i++) {
            let x, y, z;
            let color;
            let size;

            if (i < 200) { // æ˜Ÿæ˜Ÿ
                const r = Math.pow(Math.random(), 3) * 45; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta) + CONFIG.treeHeight / 2 + 20; 
                z = r * Math.cos(phi);
                color = CONFIG.colors.star;
                size = 20 + Math.random() * 30; 
            } 
            else if (i < 1700) { // æ ‘å¹²
                const h = Math.random() * CONFIG.trunkHeight;
                const r = Math.random() * CONFIG.trunkRadius;
                const angle = Math.random() * Math.PI * 2;
                x = r * Math.cos(angle);
                y = -CONFIG.treeHeight / 2 - h + 20; 
                z = r * Math.sin(angle);
                color = CONFIG.colors.trunk;
                size = 4 + Math.random() * 4;
            }
            else if (i < 2500) { // ç¯å¸¦
                const t = (i - 1700) / 800; 
                y = (t - 0.5) * CONFIG.treeHeight;
                const r = (1 - t) * CONFIG.treeBaseRadius * 1.1; 
                const angle = t * Math.PI * 2 * CONFIG.lightLoops;
                x = r * Math.cos(angle); z = r * Math.sin(angle);
                x += (Math.random() - 0.5) * 10; y += (Math.random() - 0.5) * 10; z += (Math.random() - 0.5) * 10;
                color = CONFIG.colors.lights[Math.floor(Math.random() * CONFIG.colors.lights.length)];
                size = 8 + Math.random() * 6;
            }
            else { // æ ‘å¶
                const levelProgress = Math.pow(Math.random(), 0.8); 
                const levelIndex = Math.floor(levelProgress * CONFIG.levels);
                const levelHeight = CONFIG.treeHeight / CONFIG.levels;
                const baseH = (CONFIG.treeHeight / 2) - (levelProgress * CONFIG.treeHeight);
                const layerYOffset = (Math.random() - 0.5) * levelHeight * 1.5; 
                y = baseH + layerYOffset;
                const maxR = CONFIG.treeBaseRadius * Math.pow(levelProgress, 0.9) * (1 + 0.3 * (levelIndex % 2)); 
                const rRatio = Math.sqrt(Math.random());
                const spiralAngle = levelProgress * Math.PI * 4 + (Math.random() * 0.5); 
                const theta = Math.random() * Math.PI * 2 + spiralAngle;
                let r = maxR * rRatio; y -= r * 0.3; 
                x = r * Math.cos(theta); z = r * Math.sin(theta);
                const isOrnament = Math.random() > 0.92 && rRatio > 0.6;
                if (isOrnament) {
                    color = CONFIG.colors.ornaments[Math.floor(Math.random() * CONFIG.colors.ornaments.length)];
                    size = 12 + Math.random() * 12; 
                    x *= 1.05; z *= 1.05; y -= 2;
                } else {
                    const colorIndex = Math.floor(rRatio * CONFIG.colors.leaf.length);
                    color = CONFIG.colors.leaf[Math.min(colorIndex, CONFIG.colors.leaf.length - 1)];
                    if (Math.random() > 0.95) size = 8 + Math.random() * 6; else size = 2 + Math.random() * 5; 
                }
            }

            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;
            posArray.push(x, y, z);
            colArray.push(color.r, color.g, color.b);
            sizeArray.push(size);
            particleTypes[i] = 0;

            const explosionDir = new THREE.Vector3(x, y * 0.5, z).normalize().multiplyScalar(400 + Math.random() * 800);
            randomness[i * 3] = explosionDir.x;
            randomness[i * 3 + 1] = explosionDir.y;
            randomness[i * 3 + 2] = explosionDir.z;
        }

        // --- ç”Ÿæˆæ–‡å­—ç²’å­ (æ ‡é¢˜ + å‰¯æ ‡é¢˜) ---
        for(let j=0; j<textParticleCount; j++) {
            const idx = CONFIG.particleCount + j;
            
            const x = allTextPositions[j*3];
            const y = allTextPositions[j*3+1];
            const z = allTextPositions[j*3+2];
            
            originalPositions[idx * 3] = x;
            originalPositions[idx * 3 + 1] = y;
            originalPositions[idx * 3 + 2] = z;
            
            posArray.push(x, y, z);
            
            const colVar = 0.8 + Math.random() * 0.2;
            colArray.push(CONFIG.colors.text.r * colVar, CONFIG.colors.text.g * colVar, CONFIG.colors.text.b * colVar);
            
            sizeArray.push(5 + Math.random() * 4); 
            particleTypes[idx] = 1; 

            randomness[idx * 3] = (Math.random()-0.5) * 1000;
            randomness[idx * 3 + 1] = (Math.random()) * 1000;
            randomness[idx * 3 + 2] = 500 + Math.random() * 500;
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(posArray, 3));
        geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colArray, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizeArray, 1));

        material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    /**
     * ç”ŸæˆèƒŒæ™¯é›ªèŠ±
     */
    function createBackgroundSnow() {
        const geom = new THREE.BufferGeometry();
        const pos = [];
        const sizes = [];
        const speeds = []; 
        const count = 4000; 

        for(let i=0; i<count; i++) {
            const x = (Math.random() - 0.5) * 4000;
            const y = (Math.random() - 0.5) * 4000;
            const z = (Math.random() - 0.5) * 2000 - 1000; 
            
            pos.push(x, y, z);
            sizes.push(10 + Math.random() * 15);
            speeds.push(1 + Math.random() * 3);
        }
        
        geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        geom.setAttribute('velocity', new THREE.Float32BufferAttribute(speeds, 1));
        
        const colors = [];
        for(let i=0; i<count; i++) colors.push(0.8, 0.9, 1.0); 
        geom.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));

        snowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
            },
            vertexShader: document.getElementById('vertexshader').textContent, 
            fragmentShader: document.getElementById('snowFragmentShader').textContent, 
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        backgroundSnow = new THREE.Points(geom, snowMaterial);
        scene.add(backgroundSnow);
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        
        const positions = particles.geometry.attributes.position.array;
        const sizes = particles.geometry.attributes.size.array;
        const count = positions.length / 3;

        let mode = state.visualState;

        if (state.visualState === 'EXPLODE') {
            if (Date.now() - state.explosionStartTime > 2000) {
                state.visualState = 'TREE';
            }
        }

        if (mode === 'TREE') {
            treeRotation += 0.0015;
        } else {
            treeRotation += 0.0005;
        }

        for (let i = 0; i < count; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            let tx, ty, tz;
            let lerpFactor = 0.06;

            if (i >= 1700 && i < 2500) {
                sizes[i] = (8 + Math.random() * 6) * (0.8 + 0.4 * Math.sin(time * 3 + i * 0.1));
            }

            if (mode === 'TREE') {
                const ox = originalPositions[ix];
                const oy = originalPositions[iy];
                const oz = originalPositions[iz];
                
                if (particleTypes[i] === 0) {
                    const cosR = Math.cos(treeRotation);
                    const sinR = Math.sin(treeRotation);
                    tx = ox * cosR - oz * sinR;
                    tz = ox * sinR + oz * cosR;
                    ty = oy;

                    if (i >= 1700) { 
                        const wind = Math.sin(time * 1.5 + ty * 0.01) * 5;
                        tx += wind;
                        tz += wind * 0.5;
                    }
                } else {
                    // æ–‡å­—ç²’å­ï¼šä¸æ—‹è½¬ï¼Œä¿æŒåŸå§‹ä½ç½®
                    tx = ox;
                    ty = oy + Math.sin(time * 2 + ox * 0.01) * 5; 
                    tz = oz;
                }
            } 
            else if (mode === 'EXPLODE') {
                let bx = originalPositions[ix];
                let by = originalPositions[iy];
                let bz = originalPositions[iz];
                
                if (particleTypes[i] === 0) {
                     const cosR = Math.cos(treeRotation);
                     const sinR = Math.sin(treeRotation);
                     bx = originalPositions[ix] * cosR - originalPositions[iz] * sinR;
                     bz = originalPositions[ix] * sinR + originalPositions[iz] * cosR;
                }

                tx = bx + randomness[ix] * 1.5;
                ty = by + randomness[iy] * 1.5;
                tz = bz + randomness[iz] * 1.5;
                lerpFactor = 0.08;
            } 
            else if (mode === 'CONDENSE') {
                const energyBallRadius = 180; 
                const isText = particleTypes[i] === 1;
                const rOffset = isText ? 50 : 0;
                const theta = i * 0.05 + time * 3;
                const phi = i * 0.02; 
                const r = (energyBallRadius + rOffset) * Math.pow(Math.random(), 0.33); 
                tx = r * Math.sin(theta) * Math.cos(phi);
                ty = r * Math.sin(theta) * Math.sin(phi);
                tz = r * Math.cos(theta);
                lerpFactor = 0.1;
            }

            positions[ix] += (tx - positions[ix]) * lerpFactor;
            positions[iy] += (ty - positions[iy]) * lerpFactor;
            positions[iz] += (tz - positions[iz]) * lerpFactor;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.size.needsUpdate = true;

        const bgPos = backgroundSnow.geometry.attributes.position.array;
        const bgSpeed = backgroundSnow.geometry.attributes.velocity.array;
        const bgCount = bgPos.length / 3;
        backgroundSnow.rotation.y -= 0.0002;
        for(let i=0; i<bgCount; i++) {
            bgPos[i*3+1] -= bgSpeed[i];
            if (bgPos[i*3+1] < -2000) {
                bgPos[i*3+1] = 2000;
            }
        }
        backgroundSnow.geometry.attributes.position.needsUpdate = true;
        composer.render();
    }

    function onResults(results) {
        const ui = document.getElementById('ui-layer');
        if (ui.style.opacity !== '0' && results.multiHandLandmarks) ui.style.opacity = '0';
        const status = document.getElementById('status-indicator');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20];
            let totalDist = 0;
            tips.forEach(idx => {
                const d = Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2));
                totalDist += d;
            });
            const avgDist = totalDist / 5;
            let openness = (avgDist - 0.15) / (0.45 - 0.15);
            state.handOpenness = Math.max(0, Math.min(1, openness));

            if (state.handOpenness > 0.8) status.innerText = "çŠ¶æ€: ğŸ’¥ é‡Šæ”¾";
            else if (state.handOpenness < 0.2) status.innerText = "çŠ¶æ€: ğŸŒ€ å‡èš";
            else status.innerText = "çŠ¶æ€: ğŸ„ ç”Ÿé•¿";
            
            if (state.handOpenness < 0.2) {
                state.visualState = 'CONDENSE';
            } else if (state.visualState === 'CONDENSE' && state.handOpenness > 0.5) {
                state.visualState = 'EXPLODE';
                state.explosionStartTime = Date.now();
            }
        } else {
            if (state.visualState === 'CONDENSE') state.visualState = 'TREE';
            status.innerText = "å¯»æ‰¾æ‰‹åŠ¿...";
        }
    }

    const videoElement = document.getElementById('video-input');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    
    init();
    cameraUtils.start();

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
